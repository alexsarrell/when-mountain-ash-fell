# Дизайн-документ: Отчёт о ходе разработки

**Контекст:** Балтийский научно-инженерный конкурс
**Формат:** Академическое эссе, 5-10 страниц, русский язык
**Включает:** Диаграммы Mermaid, примеры кода

---

## Структура отчёта

### 1. Введение (~0.5 страницы)

**Содержание:**
- Актуальность темы: AI в игровой индустрии, процедурная генерация контента
- Цель проекта: создание текстовой RPG с динамической генерацией нарратива и визуального контента
- Краткое описание игрового сеттинга "Когда упала Рябина" (постапокалипсис фэнтези)
- Обзор структуры отчёта

---

### 2. Технологический стек (~1 страница)

**Бэкенд:**
- Node.js 20 + Express 4 + TypeScript 5
- MongoDB 8 + Mongoose 8 (документоориентированная БД для гибкой структуры игровых данных)
- Zod 4 для валидации + автогенерация Mongoose-моделей через `@zodyac/zod-mongoose`
- OpenAI SDK (совместимость с прокси-эндпоинтами)

**Фронтенд:**
- Vanilla HTML5/CSS3/JS (без фреймворков — осознанный выбор для простоты)
- Three.js + @3d-dice/dice-box для 3D-визуализации дайсов
- Canvas API для отрисовки спрайтов
- Server-Sent Events для real-time стриминга

**Внешние сервисы:**
- LLM API (OpenAI-совместимый эндпоинт)
- Nano Banana API для генерации изображений
- AWS S3 для хранения публичных URL изображений

**Диаграмма:** Mermaid-схема технологического стека и взаимосвязей компонентов

---

### 3. Разработка бэкенда (~2.5-3 страницы)

#### 3.1 Архитектура
- Монолитная архитектура (осознанный отказ от микросервисов для учебного проекта)
- Слоистая структура: Routes → Services → Agents → Models
- Отказ от DI-контейнеров в пользу прямой инстанциации (KISS-принцип)

#### 3.2 Система агентов
- `StoryAgent` — оркестрация LLM с tool calls для бросков дайсов
- `PromptAgent` — генерация промптов для изображений персонажей/локаций
- Цикл обработки tool calls в `ChatCompletionService`

#### 3.3 Ключевые сложности

| Проблема | Решение |
|----------|---------|
| Структурированные ответы от LLM | Zod-схемы + `response_format: json_schema` |
| Цикл tool calls (дайсы могут вызываться несколько раз) | While-loop с аккумуляцией результатов в `ChatCompletionService` |
| Оптимизация генерации спрайтов | `equipmentHash` — перегенерация только при изменении экипировки |
| Единый источник правды для типов | Zod → TypeScript types + Mongoose models |
| Ограничения Nano Banana API | Вынужденная интеграция с AWS S3 |

#### 3.4 SSE-стриминг
- Проблема: множественные асинхронные события (narrative, dice_roll, images)
- Решение: EventEmitter + упорядоченная отправка событий

#### 3.5 Интеграция с сервисом генерации изображений
- **Изначальный план:** передача референсных изображений как base64/mime в Nano Banana API
- **Обнаруженное ограничение:** API не поддерживало обработку inline-изображений на момент разработки
- **Вынужденное решение:** создание S3-бакета для хранения публичных URL
- **Изменение потока:** генерация → загрузка в S3 → передача URL в API
- **Урок:** необходимость раннего прототипирования интеграций с внешними сервисами

**Диаграмма:** Sequence diagram потока обработки действия игрока

**Примеры кода:** Фрагменты из `StoryAgent`, `ChatCompletionService`, `ImageService`

---

### 4. Разработка фронтенда (~1.5-2 страницы)

#### 4.1 Архитектурное решение
- Осознанный выбор Vanilla JS без фреймворков (React/Vue)
- Обоснование: простота, отсутствие build-процесса, прямой контроль над DOM
- Модульная структура: отдельные HTML-страницы для игры и создания персонажа

#### 4.2 Основные компоненты

| Компонент | Технология | Назначение |
|-----------|------------|------------|
| Игровой чат | SSE + DOM manipulation | Real-time отображение нарратива |
| 3D дайсы | Three.js + @3d-dice/dice-box | Визуализация бросков |
| Спрайты персонажей | Canvas API | Отрисовка сгенерированных изображений |
| Инвентарь | Modal + динамический рендеринг | Управление экипировкой |

#### 4.3 Ключевые сложности

| Проблема | Решение |
|----------|---------|
| Синхронизация 3D дайсов с серверными бросками | Ожидание события `dice_roll` через SSE, затем анимация с предопределённым результатом |
| Обработка множественных SSE-событий | Конечный автомат состояний UI (loading → dice → narrative → images → done) |
| Отзывчивость интерфейса при генерации | Прогрессивное отображение: текст сразу, изображения по мере готовности |

#### 4.4 Интеграция Three.js
- Проблема: библиотека @3d-dice требует WebGL-контекст и асинхронную инициализацию
- Решение: ленивая инициализация dice-box при первом броске
- Синхронизация: анимация дайса с заранее известным результатом от сервера

**Диаграмма:** Flowchart обработки SSE-событий на клиенте

**Примеры кода:** Фрагменты из `game.html` (SSE-обработка, dice integration)

---

### 5. Интеграция компонентов (~1-1.5 страницы)

#### 5.1 Потоки данных
- Полный цикл: действие игрока → LLM → обновление состояния → генерация изображений → отображение
- Диаграмма sequence diagram всего потока

#### 5.2 Схема данных
- Zod как единый источник правды
- Трансформация: Zod Schema → TypeScript Type → Mongoose Model
- Преимущество: изменение схемы автоматически обновляет типы и валидацию БД

#### 5.3 Ключевые интеграционные сложности

| Проблема | Решение |
|----------|---------|
| Согласованность типов между клиентом и сервером | Строгие Zod-схемы для всех API-ответов |
| Порядок событий в SSE | Детерминированная последовательность: dice → narrative → location_image → character_image → done |
| Консистентность игрового состояния | Атомарное обновление в MongoDB после успешной генерации нарратива |

#### 5.4 API-контракт
- RESTful эндпоинты для CRUD операций
- SSE для игрового процесса (единственный stateful endpoint)
- Чёткое разделение: `/game/content` (статика) vs `/game/action` (динамика)

**Диаграмма:** Component diagram связей между модулями системы

---

### 6. Заключение (~0.5-1 страница)

#### 6.1 Достигнутые результаты
- Реализована функционирующая текстовая RPG с AI-генерацией нарратива
- Динамическая генерация спрайтов персонажей и локаций
- D&D-механики с визуализацией бросков дайсов
- Система инвентаря и экипировки со статами

#### 6.2 Принятые инженерные решения
- Монолитная архитектура — оправдала себя для масштаба проекта
- Vanilla JS на фронтенде — снизил сложность, ускорил разработку
- Zod-first подход — обеспечил типобезопасность на всех уровнях

#### 6.3 Экономическая целесообразность
- Текущая стоимость генерации делает production-эксплуатацию нерентабельной
- Стратегическое решение: ожидание снижения стоимости качественных моделей
- Архитектура готова к масштабированию при изменении экономических условий

#### 6.4 Перспективы развития
- Оптимизация промптов для снижения токенов
- Кэширование типовых генераций
- Мультиплеер (при снижении стоимости)

---

## Указания для агента-писателя

### Ключевые файлы для анализа и примеров кода:
- `src/agents/StoryAgent.ts` — система агентов, tool calls
- `src/services/ChatCompletionService.ts` — цикл обработки tool calls
- `src/services/GameService.ts` — SSE стриминг, оркестрация
- `src/services/ImageService.ts` — интеграция с Nano Banana + S3
- `src/schemas/` — Zod-схемы как единый источник правды
- `public/html/game.html` — фронтенд, SSE обработка, Three.js дайсы

### Диаграммы для генерации (Mermaid):
1. **Технологический стек** — блок-схема компонентов и связей
2. **Sequence diagram** — поток обработки действия игрока (бэкенд)
3. **Flowchart** — обработка SSE-событий на клиенте
4. **Component diagram** — связи между модулями системы

### Стиль написания:
- Академический, формальный русский язык
- Избегать разговорных выражений
- Использовать пассивный залог где уместно ("было реализовано", "была выбрана")
- Технические термины оставлять на английском (SSE, API, LLM, tool calls)

### Валидные проблемы для описания:
1. Структурированные ответы от LLM → Zod + json_schema
2. Цикл tool calls для дайсов → while-loop в ChatCompletionService
3. Оптимизация генерации спрайтов → equipmentHash
4. Ограничения Nano Banana API → вынужденная интеграция S3
5. Синхронизация 3D дайсов → SSE события + предопределённый результат
6. Множественные SSE-события → конечный автомат состояний UI