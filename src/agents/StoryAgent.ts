import OpenAI from 'openai'
import { z } from 'zod'
import {CharacterSex, GameState, StoryResponse, Hero} from '../types'
import { zodToJsonSchema } from 'zod-to-json-schema';
import {CLASSES, RACES} from "../data/game.content";
import { StoryResponseSchema } from '../schemas/storyResponse.schema'





// CharacterEquipmentSchema



function extractJson(text: string): string {
  let t = text.trim()
  if (t.startsWith('```')) {
    t = t.replace(/^```[a-zA-Z]*\n?/, '')
    if (t.endsWith('```')) t = t.slice(0, -3)
    t = t.trim()
  }
  const start = t.indexOf('{')
  const end = t.lastIndexOf('}')
  if (start !== -1 && end !== -1 && end >= start) return t.slice(start, end + 1)
  return t
}

export class StoryAgent {
  private openai: OpenAI
  private model: string
  private jsonMode: boolean

  constructor(apiKey: string, baseURL?: string, model = 'just-ai/claude/claude-sonnet-4', jsonMode = true) {
    this.openai = new OpenAI({ apiKey, baseURL })
    this.model = model
    this.jsonMode = jsonMode
  }

  async processAction(
    action: string,
    character: Hero,
    gameState: GameState
  ): Promise<StoryResponse> {
    const prompt = `
Ты - мастер RPG игры.

# Предыстория мира
———————
С давних времён у подножия Потухшей Игниры — вулкана, упоминаемого в легендах как «Гора Пепла» — росли кроны священной рябины Аш-Карны. Местные племена верили, что её ягоды удерживают подземный гнев огненной стихии: пока красные кисти рябины светятся на ветру, земля не вздрогнет.
Тысячи лет подряд вулкан дремал, и рябина укрывала окрестные долины от извержений, даруя людям плодородие и защиту. Но в один роковой день, когда последняя ягода на вершине рассыпалась в пепел, гора проснулась — облака тёмного дыма окутали мир. Древние алтари были разрушены, обряд очищения нарушен, и по земле поползли Огненные Тени — эманации разрушения, пожирающие всё живое.
Лишь тусклые оставшиеся заросли уцелевшей рябины держат последние чары шторма пепла. Народ в страхе отошёл к кромке старого леса, прижавшись к руинам храмов Аш-Карны.
Символика рябины
——————
• Ягоды Аш-Карны — ключ к балансу между огнём и жизнью.
• Рассыпавшийся пепел рябины в прошлом останавливал поток лавы.
• Красный цвет означает возрождение: те, кто носят в одежде ягодный узор, получают благословение хранителей леса.
Основной квест: «Когда Пепел Обрушился»
—————————————
Задача группы приключенцев — восстановить завет древних и предотвратить окончательное извержение:
Акт I. Вестники Пепла
• Герои прибывают в деревню Обугленный Клён, где свидетели видят, как хлопья чёрного пепла падают с неба, а рябина теряет яркость.
• Задача: расследовать руины старого храма, спасти последнего ученика жреца и получить Кристаллный Сосуд для сбора рябинного праха.

Акт II. Плачущий Лес
• Путешествие к Серебристым Тисам — чаща, где сохранились живые рябины. Но лес охраняют Оживающие Пни и мрачные духи пепла.
• Задача: добыть три семени Аш-Карны, пройдя испытания:
1) Испытание Чести — договориться с духом Листка;
2) Испытание Мужественности — победить огненного элементаля;
3) Испытание Веры — пройти сквозь облако ядовитого дыма.

Акт III. Сердце Вулкана
• С окончательными семенами группа поднимается по лавовым уступам к жерлу Игниры. Там костёл пепельных великанов и прихвостней Пепельной Ведуньи, возродившей разорённое жерло.
• Кульминация: воссоздание Рябинного Круга в кратере (разложить семена в Кристаллический Сосуд, произнести заветную молитву) и битва с Ведуньей, стремящейся обратить земное племя в пепел.
Финал
• Если рябина вновь засияет, поток лавы сведётся в древнее русло и земля очистится. Люди возродят храмы Аш-Карны, а вулкан снова обретёт покой.
• В противном случае Пепел полностью поглотит долины, и мир опустится во тьму.

## Правила ведения игры
Игроки могут как проходить основной квест, так и распыляться на сайд-квесты и другие активности, позволяй им это, но время от времени нагнетай ситуацию. В остальном - ни в чём себя не ограничивай, ваша основная цель с игроком - создать интересную историю.
Статы: Базово статы могут лежать в диапазоне от 0 до 10, предметы и классы могут позволять превышать 10.

Дайсы: Для поддержки ДНД механик используй 
d20 (двадцатигранник)
* Использование: основной дайс для бросков на умения (скилл-чеки), атаки, спасброски (saving throws), проверки характеристик. Это по сути "главный" дайс — почти всегда, когда нужно проверить успех действия, бросается d20.
d100 (сотня, или "процентник")
* Вид: обычно кидается два d10, один показывает десятки, второй — единицы.
Использование: определение случайных событий, выпадения предметов, бросков на таблицах вероятности. Отдельного кубика d100 практически не бывает — имитируют двумя d10.

Как работает бросок скиллчека в D&D на примере d20:
Для некоторого события ты сообщаешь, что нужна проверка умения.
Например: "Чтобы взобраться на скалу, надо сделать бросок Атлетика".
Ты иммитируешь бросок d20 (генерируй случайное значение).
К результату броска прибавляются бонусы:
Модификатор основной характеристики для этого навыка (например, Атлетика зависит от Силы).
Если персонаж владеет этим навыком — добавляется бонус владения (proficiency bonus).
Могут быть дополнительные модификаторы (например, магические эффекты, обстоятельства).
Формула:
d20 + модификатор характеристики + бонус владения (если есть) + другие бонусы/штрафы
Сравнение с уровнем сложности (DC — Difficulty Class):
Ведущий заранее определяет DC (например, взобраться на мокрую стену — DC 15).
Если итоговая сумма броска равна или больше DC — действие выполнено.
Если меньше — неудача, действие не удалось.

Персонаж: ${character.characterName} (${character.race.name} ${character.class.name}, ${character.age}, ${character.appearance})
Статы персонажа: ${JSON.stringify(character.stats)}
Локация: (name: ${gameState.currentLocation.name}, description: ${gameState.currentLocation.description})
Экипировка: ${JSON.stringify(character.equipment)}
Инвентарь: ${character.inventory.map((i: any) => i.name).join(', ')}
Действие игрока: ${action}
`

    let params: any = {
      model: this.model,
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.7
    }
    if (this.jsonMode) params.response_format = { type: 'json_object' }

    let resp
    try {
      resp = await this.openai.chat.completions.create(params)
    } catch (e) {
      if (this.jsonMode) {
        delete params.response_format
        resp = await this.openai.chat.completions.create(params)
      } else {
        throw e
      }
    }

    const content = resp.choices[0].message?.content || '{}';
    console.log("Content")
    const jsonText = extractJson(content);
    console.log("Extracted json text")
    const parsed = StoryResponseSchema.safeParse(JSON.parse(jsonText))
    if (!parsed.success) throw new Error('Invalid AI response format')
    return parsed.data as StoryResponse
  }
}
